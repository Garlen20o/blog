import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as r,e as o,o as a}from"./app-Dvgq7Lzg.js";const n="/blog/assets/derfer%E4%B8%8Easync-GPAWX_Nr.png",p={};function s(l,e){return a(),r("div",null,[...e[0]||(e[0]=[o('<h2 id="关键渲染路径" tabindex="-1"><a class="header-anchor" href="#关键渲染路径"><span>关键渲染路径</span></a></h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/Critical_rendering_path" target="_blank" rel="noopener noreferrer">关键渲染路径</a>是浏览器将 HTML，CSS 和 JavaScript 转换为屏幕上的像素所经历的步骤序列。优化关键渲染路径可提高渲染性能。关键渲染路径包含了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model" target="_blank" rel="noopener noreferrer">文档对象模型 </a>(DOM)，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CSS_Object_Model" target="_blank" rel="noopener noreferrer">CSS 对象模型 </a>(CSSOM)，渲染树和布局。</p><h3 id="浏览器渲染过程分析" tabindex="-1"><a class="header-anchor" href="#浏览器渲染过程分析"><span>浏览器渲染过程分析</span></a></h3><p>浏览器的渲染机制一般分为以下几个步骤：</p><ol><li>处理 HTML 并构建 <em><strong>DOM</strong></em> 树。</li><li>处理 CSS 构建 <em><strong>CSSOM</strong></em> 树</li><li>将 DOM 与 CSSOM 合并成一个<em><strong>渲染树</strong></em>。</li><li>根据渲染树来<em><strong>布局</strong></em>，计算每个节点的位置。</li><li>调用 GPU <em><strong>绘制</strong></em>，合成图层，显示在屏幕上。</li></ol><p>区分好：解析和渲染的区别</p><p><strong>理解并解释</strong>：</p><ul><li><p>html会解析构建DOM，由于html具有部分解析的特性。</p></li><li><p>当解析html时，遇到<link>标签就去请求css资源（不会阻塞解析），解析css构建CSSOM</p></li><li><p>html继续解析，当遇到<code>&lt;script&gt;</code> ***[3]***标签时，会阻塞html解析，并下载执行JS。（若JS先下载完，也要等到CSSOM构建完才执行)。</p></li><li><p>当CSSOM构建完 <em><strong>[1]</strong></em>，js才执行，此时html才继续解析，并构建DOM</p></li><li><p><strong>DOM</strong>和CSSOM构建完后，两者构成<strong>渲染树</strong>，然后进行<strong>布局</strong>，<strong>绘制</strong> <em>[2]</em></p></li></ul><p><strong>简单总结</strong>：一般情况下，html解析会被JS阻塞，JS执行完后，HTML才继续解析构建DOM，期间css的解析构建又会阻塞JS执行。所以最后DOM和CSSOM构建完成后，才形成渲染树。</p><p>至此关键渲染路径的过程就分析完了，需要注意以下三点。</p><p><strong>特别说明：</strong></p><p>[1] 因为js可能会去获取或改变元素的样式，所以浏览器为了不重复渲染， 等所有的css加载渲染完成后在执行js（无论js是外部还是内部）</p><p>[2] 由以上过程分析，CSSOM构建是<strong>阻塞渲染</strong>的一大原因，因为CSSOM关系到渲染树的构建，也阻塞JS的执行。</p><p>[3] 由于JS能操作DOM，修改CSS。所以修改完毕之后，又会重新执行渲染树---布局---绘制的这个阶段。</p><p>JS阻塞DOM的构建，所以JS是阻塞渲染的一大原因。</p><p>[4] 如果为<code>&lt;script&gt;</code> 添加derfer或者async属性，情况会不同。</p><h3 id="derfer与async" tabindex="-1"><a class="header-anchor" href="#derfer与async"><span>derfer与async</span></a></h3><p>1、首先明确JS会阻塞DOM构建，从而影响渲染。</p><p>2、derfer与async都是用于外部js脚本</p><p>分析：</p><table><thead><tr><th></th><th>脚本下载</th><th>执行时机</th><th>多个相同属性时的执行顺序</th></tr></thead><tbody><tr><td>derfer（推迟）</td><td>dom同时继续解析</td><td>推迟到html解析完再执行</td><td>按脚本的出现顺序</td></tr><tr><td>async（异步）</td><td>dom同时继续解析</td><td>脚本下载完立刻执行，并阻塞dom解析</td><td>先下载完，先执行</td></tr></tbody></table><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>小结：</p><p>derfer：立即下载脚本，推迟到html解析完再执行（适合与dom关联的脚本）</p><p>async：不必等下载完再解析html，也不必等脚本下载执行完再去下载另一个脚本。（适用于第三方脚本）</p><p>async脚本不该在加载期间修改dom，因为此时dom可能还没别解析出来。</p><p>也因为是异步的，不能确定谁先加载完，如果异步脚本模块之间有依赖，依赖之间就可能有误。</p><h2 id="fcp-首次加载-first-contentful-paint" tabindex="-1"><a class="header-anchor" href="#fcp-首次加载-first-contentful-paint"><span>FCP--首次加载（First Contentful Paint）</span></a></h2><p>优化首次内容绘制的三个前提：</p><ol><li><strong>提高FCP的时间其实就是在优化关键渲染路径</strong></li><li>CSS具有渲染阻碍性</li><li>JavaScript阻塞解析，html解析遇到js时，会停止解析，交给js引擎，等待js执行完毕</li></ol><p>css阻塞：cssom构建完，才能配合dom形成渲染树渲染。所以优化要将css放在head标签里和尽快启用cdn加载优化。</p><h3 id="dom渲染优化" tabindex="-1"><a class="header-anchor" href="#dom渲染优化"><span>DOM渲染优化</span></a></h3><h4 id="先了解回流和重绘" tabindex="-1"><a class="header-anchor" href="#先了解回流和重绘"><span>先了解回流和重绘</span></a></h4><ul><li>回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。</li><li>重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。</li></ul><p><strong>提高FCP 的核心只有理念之后两个 <code>减少初始化视图内容</code>和 <code>减少初始化下载资源大小</code></strong></p><h3 id="优化手段" tabindex="-1"><a class="header-anchor" href="#优化手段"><span>优化手段：</span></a></h3><p>1、初始化的js文件走异步加载，derfer和async，cdn的第三方插件放在页面底部</p><p>2、使用cdn，开启gzip</p><p>3、优化文件大小 ：减少字体包、css文件、以及js文件的大小</p><p>4、服务端渲染</p>',40)])])}const c=t(p,[["render",s]]),h=JSON.parse('{"path":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%B3%E9%94%AE%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84.html","title":"浏览器关键渲染路径到认识FCP的优化","lang":"zh-CN","frontmatter":{"title":"浏览器关键渲染路径到认识FCP的优化","description":"从浏览器关键渲染路径到认识FCP的优化","date":"2022-06-28T00:00:00.000Z","lastUpdated":true,"tags":["浏览器"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"浏览器关键渲染路径到认识FCP的优化\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-06-28T00:00:00.000Z\\",\\"dateModified\\":\\"2025-11-11T14:53:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Garlen\\",\\"url\\":\\"https://garlen20o.github.io/blog/\\"}]}"],["meta",{"property":"og:url","content":"https://garlen20o.github.io/blog/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%B3%E9%94%AE%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84.html"}],["meta",{"property":"og:site_name","content":"Garlen"}],["meta",{"property":"og:title","content":"浏览器关键渲染路径到认识FCP的优化"}],["meta",{"property":"og:description","content":"从浏览器关键渲染路径到认识FCP的优化"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-11-11T14:53:21.000Z"}],["meta",{"property":"article:tag","content":"浏览器"}],["meta",{"property":"article:published_time","content":"2022-06-28T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-11-11T14:53:21.000Z"}]]},"git":{"createdTime":1762872801000,"updatedTime":1762872801000,"contributors":[{"name":"Garlen","username":"Garlen","email":"649975243@qq.com","commits":1,"url":"https://github.com/Garlen"}]},"readingTime":{"minutes":4.39,"words":1318},"filePathRelative":"posts/浏览器关键渲染路径.md","excerpt":"<h2>关键渲染路径</h2>\\n<p><a href=\\"https://developer.mozilla.org/zh-CN/docs/Web/Performance/Critical_rendering_path\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">关键渲染路径</a>是浏览器将 HTML，CSS 和 JavaScript 转换为屏幕上的像素所经历的步骤序列。优化关键渲染路径可提高渲染性能。关键渲染路径包含了 <a href=\\"https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">文档对象模型 </a>(DOM)，<a href=\\"https://developer.mozilla.org/zh-CN/docs/Web/API/CSS_Object_Model\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">CSS 对象模型 </a>(CSSOM)，渲染树和布局。</p>"}');export{c as comp,h as data};
