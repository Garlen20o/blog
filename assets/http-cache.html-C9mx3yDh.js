import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,e as s,o as i}from"./app-Dvgq7Lzg.js";const n={};function r(p,t){return i(),a("div",null,[...t[0]||(t[0]=[s(`<h1 id="http缓存-强协商缓存" tabindex="-1"><a class="header-anchor" href="#http缓存-强协商缓存"><span>http缓存---强协商缓存</span></a></h1><h2 id="强缓存" tabindex="-1"><a class="header-anchor" href="#强缓存"><span>强缓存</span></a></h2><p>（一般是js、css、图片文件）</p><p>cache-control: max-age=31536000</p><ul><li><p>可缓存性设置</p><p>cache-control的两个值</p></li></ul><p>1、no-cache</p><p>在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证 (<strong>协商缓存验证</strong>)。</p><p>2、no-store</p><p>缓存不应存储有关客户端请求或服务器响应的任何内容，即不使用任何缓存。</p><ul><li>设置的字段</li></ul><p>强缓存相关字段有 expires，cache-control。如果 cache-control 与 expires 同时存在的话， cache-control 的优先级高于 expires。</p><ul><li>为什么需要强缓存？</li></ul><p>本质就是为服务器减压，减少网络请求。加快浏览器渲染速度。</p><h3 id="原理过程" tabindex="-1"><a class="header-anchor" href="#原理过程"><span>原理过程：</span></a></h3><ul><li><p>服务器设置<strong>响应头</strong>---cache-control</p></li><li><p>根据max-age设置缓存过期时间，</p></li><li><p>浏览器<strong>第一次</strong>发起请求，服务器返回资源和cache-control给浏览器，code：200</p></li><li><p>浏览器<strong>第二次</strong>发起请求，先检查cache-control：max-age，如果没有过期则直接从本地缓存获取资源。 code：200 (from memory cache)。如果过期，则走协商缓存逻辑，如下。</p></li></ul><h3 id="from-memory-cache-和-from-disk-cache的区别" tabindex="-1"><a class="header-anchor" href="#from-memory-cache-和-from-disk-cache的区别"><span>from memory cache 和 from disk cache的区别</span></a></h3><p>from memory cache：字面理解是从内存中，其实也是字面的含义，这个资源是直接从内存中拿到的，不会请求服务器一般已经加载过该资源且缓存在了内存当中，当关闭该页面时，此资源就被内存释放掉了，再次重新打开相同页面时不会出现from memory cache的情况</p><p>from disk cache：同上类似，此资源是从磁盘当中取出的，也是在已经在之前的某个时间加载过该资源，不会请求服务器但是此资源不会随着该页面的关闭而释放掉，因为是存在硬盘当中的，下次打开仍会from disk cache （来自：<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fgarrettzxd%2Farticle%2Fdetails%2F80684880" target="_blank" rel="noopener noreferrer">blog.csdn.net/garrettzxd/…</a> ）</p><h2 id="协商缓存" tabindex="-1"><a class="header-anchor" href="#协商缓存"><span>协商缓存</span></a></h2><ul><li>设置的字段</li></ul><p>服务器设置 <strong>last-modified</strong>（资源上次修改时间） 或 <strong>Etag</strong>（资源唯一标识）标识给浏览器（<strong>Etag更加优先</strong>）</p><p><strong>last-modified</strong>缺点：精确到秒，如果资源在一定时间内刷新，但内容没有变化，但是<strong>last-modified</strong>时间不同，就会导致实际内容一样，但依旧请求的情况</p><ul><li>为什么需要协商缓存？</li></ul><p>就是希望服务器更新资源，用户可以看到新资源，而不是读取缓存看到旧资源，所以当缓存过期时，浏览器请求携带信息，让服务器告诉浏览器这些资源是否还是最新的资源。200则更新，304则继续读取缓存</p><h3 id="原理过程-1" tabindex="-1"><a class="header-anchor" href="#原理过程-1"><span>原理过程：</span></a></h3><ul><li>本地缓存时间过期</li><li>浏览器发起请求时，请求头携带if-modified-since（if-none-match），服务器判断过期与否，告诉浏览器资源是否更新，如果不是最新，则返回<strong>code：200</strong>和最新资源，包括最新last-modified（Etag）。若未更新，服务器返回<strong>304状态码</strong>，不返回资源，直接从缓存获取资源。</li></ul><p>区别： 强缓存命中，不会请求服务器，直接请求缓存；协商缓存命中，会请求服务器，不会返回内容，然后读取缓存；</p><h2 id="举例" tabindex="-1"><a class="header-anchor" href="#举例"><span>举例：</span></a></h2><p>当浏览器第一次请求某个资源（比如 JS、CSS、图片等）时，<br> 服务器会在响应头里加上一个时间戳，表示该资源在服务器上的最后修改时间。</p><div class="language-http line-numbers-mode" data-highlighter="shiki" data-ext="http" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-http"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">HTTP</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">/</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1.1</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 200</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> OK</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Content-Type</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> text/javascript</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Cache-Control</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> max-age=3600</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Last-Modified</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> Wed, 29 Oct 2025 05:00:00 GMT</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ETag</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;abc123&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这时候：<br> 浏览器会缓存资源内容；<br> 同时把 Last-Modified（和可能的 ETag）也一并缓存下来。</p><p>Cache-Control过期就会问服务器Last-Modified或者ETag变了没</p>`,32)])])}const h=e(n,[["render",r]]),c=JSON.parse('{"path":"/posts/http-cache.html","title":"http缓存---强/协商缓存","lang":"zh-CN","frontmatter":{"title":"http缓存---强/协商缓存","description":"http缓存---强协商缓存 强缓存 （一般是js、css、图片文件） cache-control: max-age=31536000 可缓存性设置 cache-control的两个值 1、no-cache 在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证 (协商缓存验证)。 2、no-store 缓存不应存储有关客户端请求或服务器响应的...","date":"2022-06-20T00:00:00.000Z","lastUpdated":true,"tags":["http"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"http缓存---强/协商缓存\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-06-20T00:00:00.000Z\\",\\"dateModified\\":\\"2025-11-01T08:12:15.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Garlen\\",\\"url\\":\\"https://garlen20o.github.io/blog/\\"}]}"],["meta",{"property":"og:url","content":"https://garlen20o.github.io/blog/posts/http-cache.html"}],["meta",{"property":"og:site_name","content":"Garlen"}],["meta",{"property":"og:title","content":"http缓存---强/协商缓存"}],["meta",{"property":"og:description","content":"http缓存---强协商缓存 强缓存 （一般是js、css、图片文件） cache-control: max-age=31536000 可缓存性设置 cache-control的两个值 1、no-cache 在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证 (协商缓存验证)。 2、no-store 缓存不应存储有关客户端请求或服务器响应的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-11-01T08:12:15.000Z"}],["meta",{"property":"article:tag","content":"http"}],["meta",{"property":"article:published_time","content":"2022-06-20T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-11-01T08:12:15.000Z"}]]},"git":{"createdTime":1761984735000,"updatedTime":1761984735000,"contributors":[{"name":"Garlen","username":"Garlen","email":"649975243@qq.com","commits":1,"url":"https://github.com/Garlen"}]},"readingTime":{"minutes":3.25,"words":974},"filePathRelative":"posts/http-cache.md","excerpt":"\\n<h2>强缓存</h2>\\n<p>（一般是js、css、图片文件）</p>\\n<p>cache-control: max-age=31536000</p>\\n<ul>\\n<li>\\n<p>可缓存性设置</p>\\n<p>cache-control的两个值</p>\\n</li>\\n</ul>\\n<p>1、no-cache</p>\\n<p>在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证 (<strong>协商缓存验证</strong>)。</p>\\n<p>2、no-store</p>\\n<p>缓存不应存储有关客户端请求或服务器响应的任何内容，即不使用任何缓存。</p>\\n<ul>\\n<li>设置的字段</li>\\n</ul>","autoDesc":true}');export{h as comp,c as data};
